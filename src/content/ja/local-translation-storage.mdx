---
title: "ローカル翻訳ストレージパターン"
description: "信頼性・速度・オフライン対応のために、翻訳をアプリケーション内に直接バンドルする方法。"
date: "2025-03-05"
author: "James Park"
tags: ["translations", "architecture", "performance"]
---

開発中は、実行時に CDN 上のリソースから翻訳を取得する方が便利ですが、本番アプリケーションでは翻訳をローカルにバンドルした方が有利です。このパターンによりネットワークへの依存がなくなり、インタラクティブになるまでの時間が短縮され、オフラインでも動作するようになります。

## なぜ翻訳をバンドルするのか

翻訳用 CDN に障害が起きたときのことを考えてみてください。アプリケーションが実行時にそれに依存していると、ユーザーには未翻訳のコンテンツが表示されたり、最悪の場合はレイアウトが崩れたりします。翻訳をビルド成果物にバンドルしておけば、この単一障害点を完全になくすことができます。

さらに、次のようなメリットがあります。

- **レイテンシゼロ** -- ネットワークリクエストなしで、翻訳がすぐに利用できます。
- **再現可能なビルド** -- 使用される翻訳がそのままバージョン管理に記録されます。
- **シンプルなインフラ** -- CDN の設定やキャッシュ無効化を管理する必要がありません。
- **オフライン対応** -- プログレッシブ Web アプリがネットワーク接続なしでも動作します。

## パターン

ワークフローはシンプルです。開発中は CLI ツールを使って翻訳データを取得し、ローカルの JSON ファイルとして保存します。これらのファイルはソースコードと一緒にリポジトリにコミットします。

```
project/
  public/
    _gt/
      es.json
      fr.json
      ja.json
      zh.json
  src/
    loadTranslations.ts
```

ローダー関数は、現在のロケールに応じて適切なファイルをインポートします。

```typescript
export default async function loadTranslations(locale: string) {
  const translations = await import(`../public/_gt/${locale}.json`);
  return translations.default;
}
```

この関数はサーバーサイドレンダリングや静的生成のタイミングで呼び出されるため、翻訳は HTML 出力に埋め込まれた状態で生成されます。


## 翻訳を最新の状態に保つ

主なトレードオフは、翻訳を明示的に更新しなければならない点です。ソーステキストが変更されたら、再度翻訳コマンドを実行し、出力を確認して、更新されたファイルをコミットします。

これは多くのチームにとっては、実際には利点です。変更の履歴が明確になり、想定外の翻訳変更が本番環境に出てしまうのを防げます。このワークフローは、プルリクエストのレビュー プロセスに自然に組み込めます。

## このパターンを使うタイミング

ローカルストレージは、次のようなアプリケーションに最適です：

- コンテンツが随時ではなく、リリースサイクル単位で更新される。
- 信頼性とパフォーマンスを重視している。
- チームが、本番環境にデプロイする内容を完全にコントロールしたい。

コンテンツの変化が激しいアプリケーションや、対応ロケールが数百にのぼるアプリケーションでは、ハイブリッドなアプローチの方が現実的な場合があります。もっとも利用頻度の高いロケールはバンドルしてローカルに持ち、それ以外は CDN にフォールバックします。